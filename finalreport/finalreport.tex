\documentclass{sig-alternate-10pt}

\usepackage{url, enumitem}

\begin{document}

\title{RaptorQ-based File Transfer Protocol}
\author{
  Yilong Li\\
  \texttt{yilongl@cs.stanford.edu}
  \and 
  Raejoon Jung\\
  \texttt{raejoon@stanford.edu}
  \and
  Yu Yan\\
  \texttt{yuyan0@stanford.edu}
}

\maketitle
\section{Introduction}

\section{Implementation}

\subsection{Reliable file transfer}

In \texttt{TornadoTransfer}, the reliability guarantee is achieved at the application level by the use of RaptorQ code. This eliminates the need for retransmission at the file transfer application level, which greatly simplifies the design and implementation of a reliable file transfer protocol. In \texttt{TornadoTransfer}, the sender has no need to keep track of exactly what symbols are received by the receiver. Therefore, the ACK message is essentially just a bitmask of 256 bits (256 is the maximum number of blocks specified in RFC 6330) that records which blocks have been successfully decoded by the receiver. \texttt{TornadoTransfer} has a handshake procedure similar to TCP to establish the connection. Once the handshake succeeds, the sender starts sending source symbols of each block in order. Furthermore, in order to compensate for the potential lost symbols, the sender sends one repair symbol for each previously unacknowleged block after every $X$ source symbols. After all source symbols have been sent, the sender simply sends repair symbols for each unacknowleged block in a round-robin fashion. Ideally, the repair symbol transmission interval $X$ should be set to a value such that after all source symbols of block $n$ has been sent, the receiver has received enough symbols for block $n-1$ for decoding. This way, the receiver only needs to keep roughly one block in memory for decoding at a time. The receiver sends back a heartbeat ACK message constantly to compensate for potentially lost ACK messages. Besides, it immediately sends back an ACK message once it decodes a new block to reduce the probablity of sender sending more symbols for the decoded blocks. Once the receiver decodes the entire file, it simply exits. The sender will also terminate once it figures out that the receiver exits. This can be done either by relying on the shutdown mechnaism of DCCP socket or through an ICMP destination unreachable message generated by the receiver.

There are two important paramenters exposed by \texttt{libRaptorQ} through API that allow us to tune the performance of RaptorQ: symbol size and number of symbols per block.
\begin{enumerate}[label=(\alph*)]
\item \textbf{Symbol size:} In our current implementation, we choose the symbol size to be 1400 bytes to avoid IP fragmentation. We could potentially choose a larger number to, say, reduce the number of symbols for performance reason  described in the next item. However, the downside of a larger symbol size is that each symbol may be fragmented at the IP layer and the loss of each fragment results in the loss of the entire symbol. In other words, the nice property of digital fountain that every packet received contributes to the decoding of the entire file is no longer preserved. Currently, we have not quantified the effect of a larger symbol size.
\item \textbf{Number of symbols per block:} The number of symbols per block is critical to the performance of encoding and decoding. Generally speaking, we would like to keep it as small as possible. RFC 6330 does not allow us to explicitly set this value. Instead, we provide a parameter $WS$, the maximum size of a block that can be efficiently decoded in the working memory of the receiver, and RFC 6330 describes the procedure for deriving the number of symbols per block based on it. This parameter derivation algorithm involves lookups into the hardcoded RaptorQ matrices and is not very straightforward. Therefore, our current implementation enumerates paramenter $WS$ starting from a small number and increase it by one each time to search for the smallest legal value of the number of symbols per block. In pratice, this search procedure is fast enough to be hardly notieable.
\end{enumerate}


Our current implementation of \texttt{TornadoTransfer} has two performance bottlenecks which limits its practicality. We briefly describe the problems here and leave the solutions as future work.

\begin{enumerate}[label=(\alph*)]
\item \textbf{Precomputation:} The most computational expensive in RaptorQ encoding/decoding process is the process of precomputing intermediate symbols for each block. The time complexity of the precomputation is cubic in the number of symbols per block. We currently use a background thread for precomputing intermediate symbols while transmitting symbols. However, this has become a bottleneck for larger file size. For instance, for a file of size 100MB, the smallest number of symbols per block that is legal with respect to RFC 6330 is 296.
\item \textbf{Decoding:} Once intermediate symbols have been precomputed, even though both encoding and decoding are linear in the number of symbols, decoding tends to fall behind encoding for two reasons. First, encoding is a stream operation that takes constant time to generate the next symbol, while decoding is a batch operation that only happens after enough symbols of a block have been received. Second, decoding is inherently slower than encoding in the current implementation of \texttt{libRaptorQ}. To resolve this problem, we need to either parallelize the decoding process or devise a more efficient decoding algorithm.
\end{enumerate}

\subsection{Congestion control}

\section{Evaluation}

\section{Contribution}

\section{Reflection}

\section{Conclusion}


\bibliography{proposal}
\bibliographystyle{acm}

\end{document}
